<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>当代十八线浪漫主义码农诗人</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Java | Code | Book | Algorithm">
<meta property="og:type" content="website">
<meta property="og:title" content="当代十八线浪漫主义码农诗人">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="当代十八线浪漫主义码农诗人">
<meta property="og:description" content="Java | Code | Book | Algorithm">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Yannnn">
<meta property="article:tag" content="Keep Learning">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="当代十八线浪漫主义码农诗人" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">当代十八线浪漫主义码农诗人</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Java-8-Date-Time-API-详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/11/10/Java-8-Date-Time-API-%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time datetime="2021-11-10T06:41:15.000Z" itemprop="datePublished">2021-11-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/11/10/Java-8-Date-Time-API-%E8%AF%A6%E8%A7%A3/">Java 8 Date-Time API 详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <span id="more"></span>

<p>从Java版本1.0开始就支持日期和时间，主要通过<code>java.util.Date</code>类。 但是，<code>Date</code>类设计不佳。 例如，<code>Date</code>中的月份从1开始，但从日期却从0开始。在JDK 1.1中使用它的许多方法已经废弃，同时<code>java.util.Calendar</code>被引入来接管<code>Date</code>中的一些功能。 这两个是处理日期和时间的主要类，直到JDK 1.7，尽管他们被认为是不足够并且不容易处理，导致许多人诉诸第三方替代品，例如Joda Time（http://<a target="_blank" rel="noopener" href="http://joda.org/">joda.org</a>）。 JDK 1.8中的新日期和时间API解决了旧API中的许多问题，并且与Joda Time API类似。</p>
<p>这里介绍JDK 1.8中的日期 - 时间的API。</p>
<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>新的日期和时间API使得使用日期和时间非常容易。<code>java.time</code>包中包含API中的核心类。 另外，还有其他四个包，其成员使用较少：<code>java.time.chrono</code>，<code>java.time.format</code>，<code>java.time.temporal</code>和<code>java.time.zone</code>。</p>
<p>在<code>java.time</code>包中，<code>Instant</code>类表示时间线上的一个点，通常用于对时间进行操作。 <code>LocalDate</code>类为没有时间和时区部分的日期建模，例如，用于表示生日。</p>
<p>如果你需要日期和时间，那么<code>LocalDateTime</code>就是为你准备的。 例如，订单发货日期可能需要一个日期以外的时间来使订单更容易跟踪。 如果你需要一段时间但不关心日期，那么可以使用<code>LocalTime</code>。</p>
<p>如果时区很重要，日期和时间API提供<code>ZonedDateTime</code>类。 顾名思义，这个类表示带有时区日期时间。 例如，你可以使用此类来计算位于不同时区的两个机场之间的飞行时间。</p>
<p>然后有两个类来测量时间总计，即<code>Duration</code>类和<code>Period</code>类。 <strong>这两个类是相似的，除了<code>Duration</code>是基于时间，但而<code>Period</code>是基于日期的</strong>。 <code>Duration</code>提供了纳秒精度的时间量。 例如，可以模拟飞行时间，因为它通常以小时数和分钟数表示。 另一方面，如果只关心天数，月数或年数，例如计算一个人的年龄，则<code>Period</code>更为适用。</p>
<p><code>java.time</code>包也带有两个枚举<code>DayOfWeek</code>和<code>Month</code>。 <code>DayOfWeek</code>表示从一周的一天，从周一开始到周日。 <code>Month</code>枚举代表这一年的十二个月，从1月到12月。</p>
<p>处理日期和时间通常涉及解析和格式。 日期和时间API通过在所有主要类中提供<code>parse</code>和<code>format</code>方法来解决这两个问题。 另外，<code>java.time.format</code>包含一个用于格式化日期和时间的<code>DateTimeFormatter</code>类。</p>
<hr>
<h1 id="Instant类"><a href="#Instant类" class="headerlink" title="Instant类"></a>Instant类</h1><p><code>Instant</code>实例表示时间线上的一个点。 参考点是标准的Java纪元(epoch)，即1970-01-01T00：00：00Z（1970年1月1日00:00 GMT）。 <code>Instant类的</code>EPOCH<code>属性返回表示Java纪元的</code>Instant`实例。 在纪元之后的时间是正值，而在此之前的时间即是负值。</p>
<p><code>Instant</code>的静态<code>now</code>方法返回一个表示当前时间的<code>Instant</code>对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Instant now = Instant.now();</span><br></pre></td></tr></table></figure>

<p><code>getEpochSecond</code>方法返回自纪元以来经过的秒数。 <code>getNano</code>方法返回自上一秒开始以来的纳秒数。</p>
<p><code>Instant</code>类的一个常用用途是用来操作时间，如以下代码所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import java.time.Duration;</span><br><span class="line"></span><br><span class="line">import java.time.Instant;</span><br><span class="line"></span><br><span class="line">public class InstantDemo1 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Instant start = Instant.now();</span><br><span class="line"></span><br><span class="line">        // do something here</span><br><span class="line"></span><br><span class="line">        Instant end = Instant.now();</span><br><span class="line"></span><br><span class="line">        System.out.println(Duration.between(start, end).toMillis());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上面代码所示，<code>Duration</code>类用于返回两个<code>Instant</code>之间时间数量的差异。</p>
<hr>
<h1 id="LocalDate类"><a href="#LocalDate类" class="headerlink" title="LocalDate类"></a>LocalDate类</h1><p><code>LocalDate</code>类只包括日期没有时间的部分。 它也没有时区。 下表显示了<code>LocalDate</code>中一些重要的方法。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>now</td>
<td>静态方法，返回今天的日期</td>
</tr>
<tr>
<td>of</td>
<td>从指定年份，月份和日期创建LocalDate的静态方法</td>
</tr>
<tr>
<td>getDayOfMonth, getMonthValue, getYear</td>
<td>以int形式返回此LocalDate的日，月或年</td>
</tr>
<tr>
<td>getMonth</td>
<td>以Month枚举常量返回此LocalDate的月份</td>
</tr>
<tr>
<td>plusDays, minusDays</td>
<td>给LocalDate添加或减去指定的天数</td>
</tr>
<tr>
<td>plusWeeks, minusWeeks</td>
<td>给LocalDate添加或减去指定的星期数</td>
</tr>
<tr>
<td>plusMonths, minusMonths</td>
<td>给LocalDate添加或减去指定的月份数</td>
</tr>
<tr>
<td>plusYears, minusYears</td>
<td>给LocalDate添加或减去指定的年数</td>
</tr>
<tr>
<td>isLeapYear</td>
<td>检查LocalDate指定的年份是否为闰年</td>
</tr>
<tr>
<td>isAfter, isBefore</td>
<td>检查此LocalDate是在给定日期之后还是之前</td>
</tr>
<tr>
<td>lengthOfMonth</td>
<td>返回此LocalDate中月份的天数</td>
</tr>
<tr>
<td>withDayOfMonth</td>
<td>返回此LocalDate的拷贝，将月份中的某天设置为给定值</td>
</tr>
<tr>
<td>withMonth</td>
<td>返回此LocalDate的拷贝，其月份设置为给定值</td>
</tr>
<tr>
<td>withYear</td>
<td>返回此LocalDate的拷贝，并将年份设置为给定值</td>
</tr>
</tbody></table>
<p><code>LocalDate</code>提供了各种创建日期的方法。 例如，要创建代表今天日期的<code>LocalDate</code>，使用静态<code>now</code>方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalDate today = LocalDate.now();</span><br></pre></td></tr></table></figure>

<p>要创建代表特定年，月和日的<code>LocalDate</code>，使用<code>of</code>方法，该方法也是静态的。 例如，以下代码创建了一个代表2018年3月7日的<code>LocalDate</code>实例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalDate date = LocalDate.of(2018, 3, 7);</span><br></pre></td></tr></table></figure>
<p>还有一个接受<code>java.time.Month</code>枚举的常量作为第二个参数的<code>of</code>方法。 例如，下面是使用第二种方法重载构造相同日期的代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalDate date = LocalDate.of(2018, Month.MARCH, 7);</span><br></pre></td></tr></table></figure>
<p>还有获取<code>LocalDate</code>的日，月或年的方法，例如<code>getDayOfMonth</code>，<code>getMonth</code>，<code>getMonthValue</code>和<code>getYear</code>。 他们都没有任何参数，并返回一个int或<code>Month</code>的枚举常量。 另外，还有一个<code>get</code>方法，它接受一个<code>TemporalField</code>并返回这个<code>LocalDate</code>的一部分。 例如，传递<code>ChronoField.YEAR以</code>获取<code>LocalDate</code>的年份部分。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int year = localDate.get(ChronoField.YEAR);</span><br></pre></td></tr></table></figure>

<p><code>ChronoField</code>是一个实现<code>TemporalField</code>接口的枚举，因此可以传递一个<code>ChronoField</code>常量来获取。 <code>TemporalField</code>和<code>ChronoField</code>都是<code>java.time.temporal</code>包的一部分。 但是，并非<code>ChronoField</code>中的所有常量都可以<code>get</code>获取，因为并非所有常量都受支持。 例如，传递<code>ChronoField.SECOND_OF_DAY</code>以引发异常。 因此，取而代之，最好使用<code>getMonth</code>，<code>getYear</code>或类似方法来获取<code>LocalDate</code>的组件。</p>
<p>此外，还有拷贝<code>LocalDate</code>的方法，例如<code>plusDays</code>，<code>plusYears</code>，<code>minusMonths</code>等等。 例如，要获取表示明天的<code>LocalDate</code>，可以创建一个代表今天的<code>LocalDat</code>e，然后调用其<code>plusDays</code>方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalDate tomorrow = LocalDate.now().plusDays(1);</span><br></pre></td></tr></table></figure>
<p>要获取昨天表示的<code>LocalDate</code>，可以使用<code>minusDays</code>方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalDate yesterday = LocalDate.now().minusDays(1);</span><br></pre></td></tr></table></figure>
<p>另外，还有<code>plus</code>和<code>minus</code>方法以更通用的方式获得<code>LocalDate</code>的拷贝。 两者都接受一个int参数和一个<code>TemporalUnit</code>参数。 这些方法的签名如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public LocalDate plus(long amountToAdd,</span><br><span class="line"></span><br><span class="line">        java.time.temporal.TemporalUnit unit)</span><br><span class="line"></span><br><span class="line">public LocalDate minus(long amountToSubtract,</span><br><span class="line"></span><br><span class="line">        java.time.temporal.TemporalUnit unit)</span><br></pre></td></tr></table></figure>
<p>例如，获得一个从今天开始前20年的<code>LocalDate</code>，可以使用这段代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalDate pastDate = LocalDate.now().minus(2, ChronoUnit.DECADES);</span><br></pre></td></tr></table></figure>

<p><code>ChronoUnit</code>是一个实现<code>TemporalUnit</code>的枚举，因此可以将<code>ChronoUnit</code>常量传递给<code>plus</code>和<code>minus</code>方法。</p>
<p><code>LocalDate</code>是不可变的，因此无法更改。 任何返回<code>LocalDate</code>的方法都返回<code>LocalDate</code>的新实例。</p>
<p>以下是使用<code>LocalDate</code>的例子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import java.time.LocalDate;</span><br><span class="line">import java.time.temporal.ChronoField;</span><br><span class="line">import java.time.temporal.ChronoUnit;</span><br><span class="line"></span><br><span class="line">public class LocalDateDemo1 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        LocalDate today = LocalDate.now();</span><br><span class="line">         LocalDate tomorrow = today.plusDays(1);</span><br><span class="line">         LocalDate oneDecadeAgo = today.minus(1, ChronoUnit.DECADES);</span><br><span class="line"></span><br><span class="line">         System.out.println(&quot;Day of month: &quot; + today.getDayOfMonth());</span><br><span class="line">         System.out.println(&quot;Today is &quot; + today);</span><br><span class="line">         System.out.println(&quot;Tomorrow is &quot; + tomorrow);</span><br><span class="line">         System.out.println(&quot;A decade ago was &quot; + oneDecadeAgo);</span><br><span class="line">         System.out.println(&quot;Year : &quot; + today.get(ChronoField.YEAR));</span><br><span class="line">         System.out.println(&quot;Day of year:&quot; + today.getDayOfYear());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Period类"><a href="#Period类" class="headerlink" title="Period类"></a>Period类</h1><p><code>Period</code>类基于日期的时间数量构建，例如五天，一周或三年。 下面列出了一些重要的方法。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>between</td>
<td>在两个LocalDates之间创建一个Period示例</td>
</tr>
<tr>
<td>ofDays, ofWeeks, ofMonths, ofYears</td>
<td>创建代表给定天数/周/月/年的Period实例</td>
</tr>
<tr>
<td>of</td>
<td>根据给定的年数，月数和天数创建一个Period实例</td>
</tr>
<tr>
<td>getDays, getMonths, getYears</td>
<td>以int形式返回此Period的天数/月/年</td>
</tr>
<tr>
<td>isNegative</td>
<td>如果此Period的三个部分中的任何一个为负数，则返回true。 否则返回false</td>
</tr>
<tr>
<td>isZero</td>
<td>如果此Period的所有三个部分均为零，则返回true。 否则，返回false</td>
</tr>
<tr>
<td>plusDays, minusDays</td>
<td>在此Period上添加或减去给定的天数</td>
</tr>
<tr>
<td>plusMonths, minusMonths</td>
<td>在此Period上增加或减去给定的月数</td>
</tr>
<tr>
<td>plusYears, minusYears</td>
<td>在此Period增加或减去给定的年数</td>
</tr>
<tr>
<td>withDays</td>
<td>以指定的天数返回此Period的拷贝</td>
</tr>
<tr>
<td>withMonths</td>
<td>以指定的月数返回此Period的拷贝</td>
</tr>
<tr>
<td>withYears</td>
<td>以指定的年数返回此Period的拷贝</td>
</tr>
</tbody></table>
<p>创建一个<code>Period</code>很简单，这要感谢<code>between</code>,<code> of</code>,<code>ofDays</code> / <code>ofWeeks</code> / <code>ofMonths</code> / <code>ofYears</code>等静态工厂方法。 例如，以下是如何创建代表两周的<code>Period</code>实例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Period twoWeeks = Period.ofWeeks(2);</span><br></pre></td></tr></table></figure>

<p>要创建代表一年两个月三天的<code>Period</code>实例，请使用<code>of</code>方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Period p = Period.of(1, 2, 3);</span><br></pre></td></tr></table></figure>
<p>要获取某个期间的年/月/日组件，调用其<code>getYears</code> / <code>getMonths</code> / <code>getDays</code>方法。 例如，以下代码中的<code>howManyDays</code>变量的值是14。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Period twoWeeks = Period.ofWeeks(2);</span><br><span class="line"></span><br><span class="line">int howManyDays = twoWeeks.getDays();</span><br></pre></td></tr></table></figure>

<p>最后，可以使用<code>plusXXX</code>或<code>minusXXX</code>方法以及<code>withXXX</code>方法来创建<code>Period</code>的拷贝。 <code>Period</code>是不可变的，所以这些方法返回新的<code>Period</code>实例。</p>
<p>例如，下面的代码显示了一个计算个人年龄的年龄计算器。 它从两个<code>LocalDate</code>创建一个<code>Period</code>并调用它的<code>getDays</code>，<code>getMonths</code>和<code>getYears</code>方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import java.time.LocalDate;</span><br><span class="line">import java.time.Period;</span><br><span class="line"></span><br><span class="line">public class PeriodDemo1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        LocalDate dateA = LocalDate.of(1978, 8, 26);</span><br><span class="line">        LocalDate dateB = LocalDate.of(1988, 9, 28);</span><br><span class="line">        Period period = Period.between(dateA, dateB);</span><br><span class="line">        System.out.printf(&quot;Between %s and %s&quot;</span><br><span class="line">                + &quot; there are %d years, %d months&quot;</span><br><span class="line">                + &quot; and %d days%n&quot;, dateA, dateB,</span><br><span class="line">                period.getYears(),</span><br><span class="line">                period.getMonths(),</span><br><span class="line">                period.getDays());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行<code>PeriodDemo1</code>类打印下面字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Between 1978-08-26 and 1988-09-28 there are 10 years, 1 months and 2 days</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="LocalDateTime类"><a href="#LocalDateTime类" class="headerlink" title="LocalDateTime类"></a>LocalDateTime类</h1><p><code>LocalDateTime</code>类是一个没有时区的日期时间的构建。 下表显示了<code>LocalDateTime</code>中一些重要的方法。 这些方法类似于<code>LocalDate</code>的方法，以及用于修改时间部分的一些其他方法，例如在<code>LocalDate</code>中不可用的<code>plusHours</code>，<code>plusMinutes</code>和<code>plusSeconds</code>。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>now</td>
<td>返回当前日期和时间的静态方法。</td>
</tr>
<tr>
<td>of</td>
<td>从指定年份，月份，日期，小时，分钟，秒和毫秒创建LocalDateTime的静态方法。</td>
</tr>
<tr>
<td>getYear, getMonthValue, getDayOfMonth, getHour, getMinute, getSecond</td>
<td>以int形式返回此LocalDateTime的年，月，日，小时，分钟或秒部分。</td>
</tr>
<tr>
<td>plusDays, minusDays</td>
<td>给当前LocalDateTime添加或减去指定的天数。</td>
</tr>
<tr>
<td>plusWeeks, minusWeeks</td>
<td>给当前LocalDateTime添加或减去指定的周数。</td>
</tr>
<tr>
<td>plusMonths, minusMonths</td>
<td>给当前LocalDateTime添加或减去指定的月数。</td>
</tr>
<tr>
<td>plusYears, minusYears</td>
<td>给当前LocalDateTime添加或减去指定的年数。</td>
</tr>
<tr>
<td>plusHours, minusHours</td>
<td>给当前LocalDateTime添加或减去指定的小时数</td>
</tr>
<tr>
<td>plusMinutes, minusMinutes</td>
<td>给当前LocalDateTime添加或减去指定的分钟数</td>
</tr>
<tr>
<td>plusSeconds, minusSeconds</td>
<td>给当前LocalDateTime添加或减去指定的秒数</td>
</tr>
<tr>
<td>IsAfter, isBefore</td>
<td>检查此LocalDateTime是否在指定的日期时间之后或之前</td>
</tr>
<tr>
<td>withDayOfMonth</td>
<td>返回此LocalDateTime的拷贝，并将月份中的某天设置为指定值</td>
</tr>
<tr>
<td>withMonth, withYear</td>
<td>返回此LocalDateTime的拷贝，其月或年设置为指定值</td>
</tr>
<tr>
<td>withHour, withMinute, withSecond</td>
<td>返回此LocalDateTime的拷贝，其小时/分钟/秒设置为指定值</td>
</tr>
</tbody></table>
<p><code>LocalDateTime</code>提供了各种静态方法来创建日期时间。 该方法现在带有三个重载方法返回当前的日期时间。 无参的方法是最容易使用的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime now = LocalDateTime.now();</span><br></pre></td></tr></table></figure>

<p>要创建具有特定日期和时间的<code>LocalDateTime</code>，请使用<code>of</code>方法。 此方法有多个重载，并允许传递日期时间或<code>LocalDate</code>和<code>LocalTime</code>的单个部分。 以下是一些方法的签名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static LocalDateTime of(int year, int month, int dayOfMonth,</span><br><span class="line">        int hour, int minute)</span><br><span class="line"></span><br><span class="line">public static LocalDateTime of(int year, int month, int dayOfMonth,</span><br><span class="line">        int hour, int minute)</span><br><span class="line"></span><br><span class="line">public static LocalDateTime of(int year, Month month,</span><br><span class="line">        int dayOfMonth, int hour, int minute)</span><br><span class="line"></span><br><span class="line">public static LocalDateTime of(int year, Month month,</span><br><span class="line">        int dayOfMonth, int hour, int minute)</span><br><span class="line"></span><br><span class="line">public static LocalDateTime of(LocalDate date, LocalTime time)</span><br></pre></td></tr></table></figure>

<p>例如，下面的代码段创建一个<code>LocalDateTime</code>，代表2015年12月31日早上八点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime endOfYear = LocalDateTime.of(2015, 12, 31, 8, 0);</span><br></pre></td></tr></table></figure>

<p>可以使用<code>plusXXX</code>或<code>minusXXX</code>方法创建<code>LocalDateTime</code>的拷贝。 例如，此代码创建一个<code>LocalDateTime</code>，它表示明天的同一时间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime now = LocalDateTime.now();</span><br><span class="line"></span><br><span class="line">LocalDateTime sameTimeTomorrow = now.plusHours(24);</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Time-Zones"><a href="#Time-Zones" class="headerlink" title="Time Zones"></a>Time Zones</h1><p>互联网数字分配机构（IANA）维护一个可从此网页下载的时区数据库：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[http://www.iana.org/time-zones](http://www.iana.org/time-zones)</span><br></pre></td></tr></table></figure>
<p>但为了便于查看，可以访问此Wikipedia页面：<br><a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/List_of_tz_database_time_zones">http://en.wikipedia.org/wiki/List_of_tz_database_time_zones</a></p>
<p>Java日期和时间API也适用于时区。 抽象类<code>ZoneId</code>（在<code>java.time</code>包中）表示一个区域标识符。 它有一个名为<code>getAvailableZoneIds</code>的静态方法，它返回所有区域标识符。 下面展示了如何使用这种方法打印所有时区的排序列表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import java.time.ZoneId;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class TimeZoneDemo1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Set&lt;String&gt; allZoneIds = ZoneId.getAvailableZoneIds();</span><br><span class="line">        List&lt;String&gt; zoneList = new ArrayList&lt;&gt;(allZoneIds);</span><br><span class="line">        Collections.sort(zoneList);      </span><br><span class="line">        for (String zoneId : zoneList) &#123;</span><br><span class="line">            System.out.println(zoneId);</span><br><span class="line">        &#125;</span><br><span class="line">        // alternatively, you can use this line of code to</span><br><span class="line">        // print a sorted list of zone ids</span><br><span class="line">        // ZoneId.getAvailableZoneIds().stream().sorted().</span><br><span class="line">        //        forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>getAvailableZoneIds</code>返回字符串的<code>Set</code>集合。 可以使用<code>Collections.sort()</code>或更优雅地通过调用它的<code>stream</code>方法对<code>Set</code>进行排序。 可以编写此代码对区域标识符进行排序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZoneId.getAvailableZoneIds().stream().sorted()</span><br><span class="line">        .forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p><code>getAvailableZoneIds</code>返回586个区域标识符的<code>Set</code>集合。 以下是上述代码中的一部分区域标识符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Africa/Cairo</span><br><span class="line">Africa/Johannesburg</span><br><span class="line">America/Chicago</span><br><span class="line">America/Los_Angeles</span><br><span class="line">America/Mexico_City</span><br><span class="line">America/New_York</span><br><span class="line">America/Toronto</span><br><span class="line">Antarctica/South_Pole</span><br><span class="line">Asia/Hong_Kong</span><br><span class="line">Asia/Shanghai</span><br><span class="line">Asia/Tokyo</span><br><span class="line">Australia/Melbourne</span><br><span class="line">Australia/Sydney</span><br><span class="line">Canada/Atlantic</span><br><span class="line">Europe/Amsterdam</span><br><span class="line">Europe/London</span><br><span class="line">Europe/Paris</span><br><span class="line">US/Central</span><br><span class="line">US/Eastern</span><br><span class="line">US/Pacific</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="ZonedDateTime"><a href="#ZonedDateTime" class="headerlink" title="ZonedDateTime"></a>ZonedDateTime</h1><p><code>ZonedDateTime</code>类以一个时区为日期时间的构建。例如，以下是一个时区的日期时间:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2015-12-31T10:59:59+01:00 Europe/Paris</span><br></pre></td></tr></table></figure>
<p><code>ZonedDateTime</code>始终是不可变的，时间分量的存储精度为纳秒。</p>
<p><code>ZonedDateTIme</code>中一些重要方法的使用与<code>LocalDateTime</code>类似，只是多了一个时区的概念。可自行查阅API。</p>
<p>像<code>LocalDateTime</code>一样，<code>ZonedDateTime</code>类现在提供静态<code>now</code>和<code>of</code>方法，并构造一个<code>ZonedDateTime</code>实例。 <code>now</code>方法创建一个<code>ZonedDateTime</code>代表执行的日期和时间。 无参<code>now</code>方法会使用计算机的默认时区创建<code>ZonedDateTime</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZonedDateTime now = ZonedDateTime.now();</span><br></pre></td></tr></table></figure>
<p><code>now</code>的另一个重载方法允许传递区域标识符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZonedDateTime parisTime =</span><br><span class="line">        ZonedDateTime.now(ZoneId.of(&quot;Europe/Paris&quot;));</span><br></pre></td></tr></table></figure>

<p><code>of</code>方法也有好几个重载的方法。在所有情况下，都需要传递区域标识符。 第一个重载方法允许传递时区日期时间的每个部分，从年份到纳秒。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static ZonedDateTime of(int year, int month, int dayOfMonth,</span><br><span class="line">        int hour, int minute, int second, int nanosecond,</span><br><span class="line">        ZoneId zone)</span><br></pre></td></tr></table></figure>

<p><code>of</code>方法的第二个重载方法需要<code>LocalDate</code>，<code>LocalTime</code>和<code>ZoneId</code>参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public static ZonedDateTime of(LocalDate date, LocalTime time,</span><br><span class="line">        ZoneId zone)</span><br></pre></td></tr></table></figure>

<p><code>of</code>方法的最后一个重载方法需要<code>LocalDateTime</code>和<code>ZoneId</code>参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static ZonedDateTime of(LocalDateTime datetime, ZoneId zone)</span><br></pre></td></tr></table></figure>

<p>像<code>LocalDate</code>和<code>LocalDateTime</code>一样，<code>ZonedDateTime</code>提供了使用<code>plusXXX</code>，<code>minusXXX</code>和<code>withXXX</code>方法创建实例拷贝的方法。</p>
<p>例如，下面代码行创建一个带默认时区的<code>ZonedDateTime</code>，并调用它的<code>minusDays</code>方法以在三天前创建相同的<code>ZonedDateTime</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZonedDateTime now = ZonedDateTime.now();</span><br><span class="line">ZonedDateTime threeDaysEarlier = now.minusDays(3);</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Duration"><a href="#Duration" class="headerlink" title="Duration"></a>Duration</h1><p><code>Duration</code>类是基于时间的持续时间的构建。 它与<code>Period</code>类似，不同之处在于<code>Duration</code>的时间分量为纳秒精度，并考虑了<code>ZonedDateTime</code>实例之间的时区。 下表显示了<code>Duration</code>中重要的方法。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>between</td>
<td>在两个时差的对象之间创建一个Duration实例，例如在两个LocalDateTime或两个ZonedDateTime之间。</td>
</tr>
<tr>
<td>ofYears, ofMonths, ofWeeks, ofDays, ofHours, ofMinutes, ofSeconds, ofNano</td>
<td>创建给定年数/月/周/天/小时/分钟/秒/纳秒的Duration实例</td>
</tr>
<tr>
<td>of</td>
<td>根据指定数量的时间单位创建Duration实例</td>
</tr>
<tr>
<td>toDays, toHours, toMinutes</td>
<td>以int形式返回此Duration的天数/小时/分钟数</td>
</tr>
<tr>
<td>isNegative</td>
<td>如果此Duration为负，则返回true。 否则返回false。</td>
</tr>
<tr>
<td>isZero</td>
<td>如果此Duration长度为零，则返回true。 否则，返回false</td>
</tr>
<tr>
<td>plusDays, minusDays</td>
<td>在此Duration内添加或减去指定的天数。</td>
</tr>
<tr>
<td>plusMonths, minusMonths</td>
<td>在此Duration内添加或减去指定的月数。</td>
</tr>
<tr>
<td>plusYears, minusYears</td>
<td>在Duration内添加或减去指定的年数</td>
</tr>
<tr>
<td>withSeconds</td>
<td>以指定的秒数返回此Duration的拷贝。</td>
</tr>
</tbody></table>
<p>可以通过调用静态方法<code>between</code>或<code>of</code>来创建<code>Duration</code>。 下面的代码会在2015年1月26日11:10至2015年1月26日12:40之间创建两个<code>LocalDateTime</code>的<code>Duration</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import java.time.Duration;</span><br><span class="line">import java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line">public class DurationDemo1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        LocalDateTime dateTimeA = LocalDateTime</span><br><span class="line">                .of(2015, 1, 26, 8, 10, 0, 0);</span><br><span class="line">        LocalDateTime dateTimeB = LocalDateTime</span><br><span class="line">                .of(2015, 1, 26, 11, 40, 0, 0);</span><br><span class="line">        Duration duration = Duration.between(</span><br><span class="line">                dateTimeA, dateTimeB);</span><br><span class="line"></span><br><span class="line">        System.out.printf(&quot;There are %d hours and %d minutes.%n&quot;,</span><br><span class="line">                duration.toHours(),</span><br><span class="line">                duration.toMinutes() % 60);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行<code>DurationDemo1</code>类的结果是这样的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">There are 3 hours and 30 minutes.</span><br></pre></td></tr></table></figure>
<p>下面的代码在两个<code>ZoneDateTime</code>之间创建一个<code>Duration</code>，具有相同的日期和时间，但时区不同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import java.time.Duration;</span><br><span class="line">import java.time.LocalDateTime;</span><br><span class="line">import java.time.Month;</span><br><span class="line">import java.time.ZoneId;</span><br><span class="line">import java.time.ZonedDateTime;</span><br><span class="line"></span><br><span class="line">public class DurationDemo2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ZonedDateTime zdt1 = ZonedDateTime.of(</span><br><span class="line">                LocalDateTime.of(2015, Month.JANUARY, 1,</span><br><span class="line">                        8, 0),</span><br><span class="line">                ZoneId.of(&quot;America/Denver&quot;));</span><br><span class="line">        ZonedDateTime zdt2 = ZonedDateTime.of(</span><br><span class="line">                LocalDateTime.of(2015, Month.JANUARY, 1,</span><br><span class="line">                        8, 0),</span><br><span class="line">                ZoneId.of(&quot;America/Toronto&quot;));</span><br><span class="line"></span><br><span class="line">        Duration duration = Duration.between(zdt1, zdt2);</span><br><span class="line">        System.out.printf(&quot;There are %d hours and %d minutes.%n&quot;,</span><br><span class="line">                duration.toHours(),</span><br><span class="line">                duration.toMinutes() % 60);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行<code>DurationDemo2</code>类在控制台上打印如下结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">There are -2 hours and 0 minutes.</span><br></pre></td></tr></table></figure>
<p>这是预料之中的，因为时区<code>America/Denver</code>和<code>America/Toronto</code>之间有两个小时的差异。</p>
<p>作为一个更复杂的例子，下面的代码显示了一个公交车旅行时间计算器。 它有一个方法<code>calculateTravelTime</code>，它需要一个离开的<code>ZonedDateTime</code>实例和一个到达的<code>ZonedDateTime</code>实例。 该代码调用<code>calculateTravelTime</code>方法两次。 这两次公交车都在丹佛早上8点从科罗拉多州丹佛出发，并于多伦多时间第二天早上8点抵达多伦多。 公交车首次于2014年3月8日启程，第二次于2014年3月18日启程。</p>
<p>两种情况下的旅行时间是多少?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import java.time.Duration;</span><br><span class="line">import java.time.LocalDateTime;</span><br><span class="line">import java.time.Month;</span><br><span class="line">import java.time.ZoneId;</span><br><span class="line">import java.time.ZonedDateTime;</span><br><span class="line"></span><br><span class="line">public class TravelTimeCalculator &#123;</span><br><span class="line">    public Duration calculateTravelTime(</span><br><span class="line">            ZonedDateTime departure, ZonedDateTime arrival) &#123;</span><br><span class="line">        return Duration.between(departure, arrival);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        TravelTimeCalculator calculator =</span><br><span class="line">                new TravelTimeCalculator();</span><br><span class="line">        ZonedDateTime departure1 = ZonedDateTime.of(</span><br><span class="line">                LocalDateTime.of(2014, Month.MARCH, 8,</span><br><span class="line">                        8, 0),</span><br><span class="line">                ZoneId.of(&quot;America/Denver&quot;));</span><br><span class="line">        ZonedDateTime arrival1 = ZonedDateTime.of(</span><br><span class="line">                LocalDateTime.of(2014, Month.MARCH, 9,</span><br><span class="line">                        8, 0),</span><br><span class="line">                ZoneId.of(&quot;America/Toronto&quot;));</span><br><span class="line">        Duration travelTime1 = calculator</span><br><span class="line">                .calculateTravelTime(departure1, arrival1);</span><br><span class="line">        System.out.println(&quot;Travel time 1: &quot;</span><br><span class="line">                + travelTime1.toHours() + &quot; hours&quot;);</span><br><span class="line"></span><br><span class="line">        ZonedDateTime departure2 = ZonedDateTime.of(</span><br><span class="line">                LocalDateTime.of(2014, Month.MARCH, 18,</span><br><span class="line">                        8, 0),</span><br><span class="line">                ZoneId.of(&quot;America/Denver&quot;));</span><br><span class="line">        ZonedDateTime arrival2 = ZonedDateTime.of(</span><br><span class="line">                LocalDateTime.of(2014, Month.MARCH, 19,</span><br><span class="line">                        8, 0),</span><br><span class="line">                ZoneId.of(&quot;America/Toronto&quot;));</span><br><span class="line">        Duration travelTime2 = calculator</span><br><span class="line">                .calculateTravelTime(departure2, arrival2);</span><br><span class="line">        System.out.println(&quot;Travel time 2: &quot;</span><br><span class="line">                + travelTime2.toHours() + &quot; hours&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Travel time 1: 21 hours</span><br><span class="line"></span><br><span class="line">Travel time 2: 22 hours</span><br></pre></td></tr></table></figure>
<p>为什么有这个区别？ 因为2014年的夏令时从3月9日星期日凌晨2点开始。 因此，在2014年3月8日至2014年3月9日之间“失去”了一小时。</p>
<hr>
<h1 id="Formatting-A-Date-Time"><a href="#Formatting-A-Date-Time" class="headerlink" title="Formatting A Date-Time"></a>Formatting A Date-Time</h1><p>可以使用<code>java.time.format.DateTimeFormatter</code>格式化本地或时区日期时间。<code>LocalDate</code>，<code>LocalDateTime</code>，<code>LocalTime</code>和<code>ZoneDateTime</code>类提供具有以下签名的格式方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public java.lang.String format(java.time.format.DateTimeFormatter</span><br><span class="line">        formatter)</span><br></pre></td></tr></table></figure>

<p>很明显，要格式化日期或时间，必须首先创建<code>DateTimeFormatter</code>实例。</p>
<p>下面的代码使用两个格式化实例格式化当前日期。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import java.time.LocalDateTime;</span><br><span class="line">import java.time.format.DateTimeFormatter;</span><br><span class="line">import java.time.format.FormatStyle;</span><br><span class="line"></span><br><span class="line">public class DateTimeFormatterDemo1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        DateTimeFormatter formatter1 = DateTimeFormatter</span><br><span class="line">                .ofLocalizedDateTime(FormatStyle.MEDIUM);</span><br><span class="line">        LocalDateTime example = LocalDateTime.of(</span><br><span class="line">                2000, 3, 19, 10, 56, 59);</span><br><span class="line">        System.out.println(&quot;Format 1: &quot; + example</span><br><span class="line">                .format(formatter1));       </span><br><span class="line"></span><br><span class="line">        DateTimeFormatter formatter2 = DateTimeFormatter</span><br><span class="line">                .ofPattern(&quot;MMMM dd, yyyy HH:mm:ss&quot;);</span><br><span class="line">        System.out.println(&quot;Format 2: &quot; +</span><br><span class="line">                example.format(formatter2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：（第一个结果取决于你的区域设置）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Format 1: 19-Mar-2000 10:56:59 AM</span><br><span class="line"></span><br><span class="line">Format 2: March 19, 2000 10:56:59</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Parsing-A-Date-Time"><a href="#Parsing-A-Date-Time" class="headerlink" title="Parsing A Date-Time"></a>Parsing A Date-Time</h1><p>在Java Date和Time API的许多类中有两种<code>parse</code>方法。第一个需要格式化实例，第二个则不需要。后一个方法会根据默认模式解析日期时间。要使用自己的格式化模式，请使用<code>DateTimeFormatter</code>。如果传递的字符串不能被解析，那么解析方法将抛出一个<code>DateTimeParseException</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import java.time.LocalDate;</span><br><span class="line">import java.time.Period;</span><br><span class="line">import java.time.format.DateTimeFormatter;</span><br><span class="line">import java.time.format.DateTimeParseException;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class AgeCalculator &#123;</span><br><span class="line">    DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-M-d&quot;);</span><br><span class="line">    public Period calculateAge(LocalDate birthday) &#123;</span><br><span class="line">        LocalDate today = LocalDate.now();</span><br><span class="line">        return Period.between(birthday, today);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public LocalDate getBirthday() &#123;</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        LocalDate birthday;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            System.out.println(&quot;Please enter your birthday &quot;</span><br><span class="line">                    + &quot;in yyyy-MM-dd format (e.g. 1980-9-28): &quot;);</span><br><span class="line">            String input = scanner.nextLine();</span><br><span class="line">            try &#123;</span><br><span class="line">                birthday = LocalDate.parse(input, formatter);</span><br><span class="line">                return birthday;</span><br><span class="line">            &#125; catch(DateTimeParseException e) &#123;</span><br><span class="line">                System.out.println(&quot;Error! Please try again&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AgeCalculator ageCalculator = new AgeCalculator();</span><br><span class="line">        LocalDate birthday = ageCalculator.getBirthday();</span><br><span class="line">        Period age = ageCalculator.calculateAge(birthday);</span><br><span class="line">        System.out.printf(&quot;Today you are %d years, %d months&quot;</span><br><span class="line">                + &quot; and %d days old%n&quot;,</span><br><span class="line">                age.getYears(), age.getMonths(), age.getDays());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AgeCalculator</code>类有两个方法，<code>getBirthday</code>和<code>calculateAge</code>。 <code>getBirthday</code>方法使用<code>Scanner</code>类来读取用户输入，并使用<code>DateTimeFormatter</code>类将输入解析到<code>LocalDate</code>中。 <code>getBirthday</code>方法一直请求一个日期，直到用户输入正确格式的日期，在这种情况下，方法返回。 <code>calculateAge</code>方法需要一个生日，并在生日和今天的日期之间创建一个<code>Period</code>实例。</p>
<p>如果运行这个例子，会在控制台上看到这个。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Please enter your birthday in yyyy-MM-dd format (e.g. 1980-9-28):</span><br></pre></td></tr></table></figure>
<p>如果以正确的格式输入日期，则程序将打印计算的年龄，如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Today you are 79 years, 0 months and 15 days old</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><p>Java 8带来了全新的Date-Time API来替代以<code>java.util.Date</code>类为中心的旧的API。 通过本篇文章，学习如何使用新API中的核心类，如<code>Instant</code>，<code>LocalDate</code>，<code>LocalDateTime</code>，<code>ZonedDateTime</code>，<code>Period</code>和<code>Duration</code>，以及学习如何格式化和解析日期时间。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/11/10/Java-8-Date-Time-API-%E8%AF%A6%E8%A7%A3/" data-id="ckvt5n91e0000gou04zla9g8a" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Redis分布式锁的使用与实现原理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/12/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" class="article-date">
  <time datetime="2017-01-12T03:24:12.000Z" itemprop="datePublished">2017-01-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/12/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">Redis分布式锁的使用与实现原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <span id="more"></span>

<p>模拟一个电商里面下单减库存的场景。<br>1.首先在redis里加入商品库存数量。</p>
<p><img src="http://r2cex8oik.hn-bkt.clouddn.com/4366140-7af289492d769d1a.png?e=1636529710&token=OT9og19NZkfkIC26ReeRgef23x-I0BmEqhXX1pvD:prey2F7Zpz7mcOjyWIdsolyxKw0="></p>
<p>2.新建一个Spring Boot项目，在pom里面引入相关的依赖。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>3.接下来，在application.yml配置redis属性和指定应用的端口号：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8090</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  redis:</span><br><span class="line">    host: 192.168.0.60</span><br><span class="line">    port: 6379</span><br></pre></td></tr></table></figure>
<p>4.新建一个Controller类，扣减库存第一版代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StockController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(StockController.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/reduceStock&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reduceStock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从redis中获取库存数量</span></span><br><span class="line">        <span class="keyword">int</span> stock = Integer.parseInt(Objects.requireNonNull(stringRedisTemplate.opsForValue().get(<span class="string">&quot;stockCount&quot;</span>)));</span><br><span class="line">        <span class="keyword">if</span> (stock &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 减库存</span></span><br><span class="line">            <span class="keyword">int</span> restStock = stock - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 剩余库存再重新设置到redis中</span></span><br><span class="line">            stringRedisTemplate.opsForValue().set(<span class="string">&quot;stockCount&quot;</span>, String.valueOf(restStock));</span><br><span class="line">            logger.info(<span class="string">&quot;扣减成功，剩余库存：&#123;&#125;&quot;</span>, restStock);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;库存不足，扣减失败。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面第一版的代码存在什么问题：超卖。假如多个线程同时调用获取库存数量的代码，那么每个线程拿到的都是100，判断库存都大于0，都可以执行减库存的操作。假如两个线程都做减库存更新缓存，那么缓存的库存变成99，但实际上，应该是减掉2个库存。<br>那么很多人的第一个想法是加synchronized同步代码块，因为获取数量和减库存不是原子性操作，有多个线程来执行代码的时候，只允许一个线程执行代码块里的代码。那么改完的第二版的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/reduceStock&quot;)</span><br><span class="line">   public String reduceStock() &#123;</span><br><span class="line">       synchronized (this) &#123;</span><br><span class="line">           // 从redis中获取库存数量</span><br><span class="line">           int stock = Integer.parseInt(Objects.requireNonNull(stringRedisTemplate.opsForValue().get(&quot;stockCount&quot;)));</span><br><span class="line">           if (stock &gt; 0) &#123;</span><br><span class="line">               // 减库存</span><br><span class="line">               int restStock = stock - 1;</span><br><span class="line">               // 剩余库存再重新设置到redis中</span><br><span class="line">               stringRedisTemplate.opsForValue().set(&quot;stockCount&quot;, String.valueOf(restStock));</span><br><span class="line">               logger.info(&quot;扣减成功，剩余库存：&#123;&#125;&quot;, restStock);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               logger.info(&quot;库存不足，扣减失败。&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       return &quot;success&quot;;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>但使用synchronize存在的问题，就是只能保证单机环境运行时没有问题的。但现在的软件公司里，基本上都是集群架构，是多实例，前面使用Nginx做负载均衡，大概架构如下：<br><img src="http://r2cex8oik.hn-bkt.clouddn.com/4366140-911642e27b2969f2.png?e=1636529710&token=OT9og19NZkfkIC26ReeRgef23x-I0BmEqhXX1pvD:bvNdhvHxTz75oW6x1hfwBe-bPsU="></p>
<p> Nginx分发请求，把请求发送到不同的Tomcat容器，而synchronize只能保证一个应用是没有问题的。</p>
<p>那么代码改进第三版，就是引入redis分布式锁，具体代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/reduceStock&quot;)</span><br><span class="line">   public String reduceStock() &#123;</span><br><span class="line">       String lockKey = &quot;stockKey&quot;;</span><br><span class="line">       try &#123;</span><br><span class="line">           boolean result = stringRedisTemplate.opsForValue().setIfAbsent(lockKey, &quot;1&quot;);</span><br><span class="line">           if (!result) &#123;</span><br><span class="line">               return &quot;errorCode&quot;;</span><br><span class="line">           &#125;</span><br><span class="line">           // 从redis中获取库存数量</span><br><span class="line">           int stock = Integer.parseInt(Objects.requireNonNull(stringRedisTemplate.opsForValue().get(&quot;stockCount&quot;)));</span><br><span class="line">           if (stock &gt; 0) &#123;</span><br><span class="line">               // 减库存</span><br><span class="line">               int restStock = stock - 1;</span><br><span class="line">               // 剩余库存再重新设置到redis中</span><br><span class="line">               stringRedisTemplate.opsForValue().set(&quot;stockCount&quot;, String.valueOf(restStock));</span><br><span class="line">               logger.info(&quot;扣减成功，剩余库存：&#123;&#125;&quot;, restStock);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               logger.info(&quot;库存不足，扣减失败。&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           stringRedisTemplate.delete(lockKey)</span><br><span class="line">       &#125;</span><br><span class="line">       return &quot;success&quot;;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>如果有一个线程拿到锁，那么其他的线程就会等待。一定要记得在finally里面把使用完的锁要删除掉。否则一旦抛出异常，只有一个线程会一直持有锁，其他线程没有机会获取。<br>但如果在执行<code>if (stock &gt; 0) &#123;</code>代码块里的代码，因为宕机或重启没有执行完，也会一直持有锁，所以，这里需要把锁加一个超时时间：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">boolean result = stringRedisTemplate.opsForValue().setIfAbsent(lockKey, &quot;1&quot;);</span><br><span class="line">stringRedisTemplate.expire(lockKey, 10, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<p>但如果上面两行代码在中间执行出问题了，设置超时时间的代码还没执行，也会出现锁不能释放的问题。好在有对应的方法：就是把上面两行代码设置成一个原子操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 这里默认设置超时时间为10秒</span><br><span class="line">boolean result = stringRedisTemplate.opsForValue().setIfAbsent(lockKey, &quot;1&quot;, 10, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<p>到此为止，如果并发量不是很大的话，基本上是没有问题的。</p>
<p>但是，如果请求的并发量很大，就会出现新的问题：有种比较特殊的情况，第一个线程执行了15秒，但是执行到10秒钟的时候，锁已经失效释放了，那么在高并发场景下，第二个线程发现锁已经失效，那么它就可以拿到这把锁进行加锁，<br>假设第二个线程执行需要8秒，它执行到5秒钟后，此时第一个线程已经执行完了，执行完那一刻，进行了删除key的操作，但是此时的锁是第二个线程加的，这样第一个线程把第二个线程加的锁删掉了。<br>那意味着第三个线程又可以拿到锁，第三个线程执行了3秒钟，此时第二个线程执行完毕，那么第二个线程把第三个线程的锁又删除了。导致锁失效。<br>那么解决的思路就是，我自己加的锁，不要被别人删掉。那么可以为每个进来的请求生成一个唯一的id，作为分布式锁的值，然后在释放时，判断一下当前线程的id，是不是和缓存里的id是否相等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/reduceStock&quot;)</span><br><span class="line">   public String reduceStock() &#123;</span><br><span class="line">       String lockKey = &quot;stockKey&quot;;</span><br><span class="line">       String id = UUID.randomUUID().toString();</span><br><span class="line">       try &#123;</span><br><span class="line">           // 这里默认设置超时时间为30秒</span><br><span class="line">           boolean result = stringRedisTemplate.opsForValue().setIfAbsent(lockKey, id, 30, TimeUnit.SECONDS);</span><br><span class="line">           if (!result) &#123;</span><br><span class="line">               return &quot;errorCode&quot;;</span><br><span class="line">           &#125;</span><br><span class="line">           // 从redis中获取库存数量</span><br><span class="line">           int stock = Integer.parseInt(Objects.requireNonNull(stringRedisTemplate.opsForValue().get(&quot;stockCount&quot;)));</span><br><span class="line">           if (stock &gt; 0) &#123;</span><br><span class="line">               // 减库存</span><br><span class="line">               int restStock = stock - 1;</span><br><span class="line">               // 剩余库存再重新设置到redis中</span><br><span class="line">               stringRedisTemplate.opsForValue().set(&quot;stockCount&quot;, String.valueOf(restStock));</span><br><span class="line">               logger.info(&quot;扣减成功，剩余库存：&#123;&#125;&quot;, restStock);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               logger.info(&quot;库存不足，扣减失败。&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           if (id.contentEquals(Objects.requireNonNull(stringRedisTemplate.opsForValue().get(lockKey)))) &#123;</span><br><span class="line">               stringRedisTemplate.delete(lockKey);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return &quot;success&quot;;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>到此为止，一个比较完善的锁就实现了，可以应付大部分场景。<br>当然，上面的代码还有一个问题，就是一个线程执行时间超过了过期时间，后面的代码还没有执行完，锁就已经删除了，还是会有些bug存在。解决的方法是给锁续命的操作。<br>在当前主线程获取到锁以后，可以fork出一个线程，执行Timer定时器操作，假如默认超时时间为30秒，那么定时器每隔10秒去看下这把锁还是否存在，存在就说明这个锁里的逻辑还没有执行完，那么就可以把当前主线程的超时时间重新设置为30秒；如果不存在，就直接结束掉。</p>
<p>但是上面的逻辑，在高并发场景下，实现比较完善还是比较困难的。好在现在已经有比较成熟的框架，那就是Redisson。官方地址<a target="_blank" rel="noopener" href="https://redisson.org./">https://redisson.org。</a><br>下面用Redisson来实现分布式锁。<br>首先引入依赖包：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.redisson&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;redisson&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;3.6.5&lt;/version&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>配置类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class RedissonConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public Redisson redisson() &#123;</span><br><span class="line">        // 单机模式</span><br><span class="line">        Config config = new Config();</span><br><span class="line">        config.useSingleServer().setAddress(&quot;redis://192.168.0.60:6379&quot;).setDatabase(0);</span><br><span class="line">        return (Redisson) Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来用redisson重写上面的减库存操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line">   <span class="keyword">private</span> Redisson redisson;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@RequestMapping(&quot;/reduceStock&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">reduceStock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       String lockKey = <span class="string">&quot;stockKey&quot;</span>;</span><br><span class="line">       RLock redissonLock = redisson.getLock(lockKey);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 加锁，锁续命</span></span><br><span class="line">           redissonLock.lock();</span><br><span class="line">           <span class="comment">// 从redis中获取库存数量</span></span><br><span class="line">           <span class="keyword">int</span> stock = Integer.parseInt(Objects.requireNonNull(stringRedisTemplate.opsForValue().get(<span class="string">&quot;stockCount&quot;</span>)));</span><br><span class="line">           <span class="keyword">if</span> (stock &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">// 减库存</span></span><br><span class="line">               <span class="keyword">int</span> restStock = stock - <span class="number">1</span>;</span><br><span class="line">               <span class="comment">// 剩余库存再重新设置到redis中</span></span><br><span class="line">               stringRedisTemplate.opsForValue().set(<span class="string">&quot;stockCount&quot;</span>, String.valueOf(restStock));</span><br><span class="line">               logger.info(<span class="string">&quot;扣减成功，剩余库存：&#123;&#125;&quot;</span>, restStock);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               logger.info(<span class="string">&quot;库存不足，扣减失败。&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          redissonLock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>其实就是三个步骤：获取锁，加锁，释放锁。</p>
<p>先简单看下Redisson的实现原理：<br><img src="https://upload-images.jianshu.io/upload_images/4366140-abb8a67fe0264a6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>
<p>这里先说一下Redis很多操作使用Lua脚本来实现原子性操作，关于Lua语法，可以去网上找下相关教程。<br>使用Lua脚本的好处有：<br>1.减少网络开销，多个命令可以使用一次请求完成；<br>2.实现了原子性操作，Redis会把Lua脚本作为一个整体去执行；<br>3.实现事务，Redis自带的事务功能有限，而Lua脚本实现了事务的常规操作，而且还支持回滚。</p>
<p>但是Lua实际上不会使用很多，如果Lua脚本执行时间过长，因为Redis是单线程，因此会导致堵塞。</p>
<p>最后，说下Redisson分布式锁的代码实现，<br>找到上面的redissonLock.lock()；<br>lock方法点进去，一直点到RedissonLock类里面的lockInterruptibly方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">    @Override</span><br><span class="line">    public void lockInterruptibly(long leaseTime, TimeUnit unit) throws InterruptedException &#123;</span><br><span class="line">        // 获取线程id</span><br><span class="line">        long threadId = Thread.currentThread().getId();</span><br><span class="line">        Long ttl = tryAcquire(leaseTime, unit, threadId);</span><br><span class="line">        // lock acquired</span><br><span class="line">        if (ttl == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        RFuture&lt;RedissonLockEntry&gt; future = subscribe(threadId);</span><br><span class="line">        commandExecutor.syncSubscription(future);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                ttl = tryAcquire(leaseTime, unit, threadId);</span><br><span class="line">                // lock acquired</span><br><span class="line">                if (ttl == null) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // waiting for message</span><br><span class="line">                if (ttl &gt;= 0) &#123;</span><br><span class="line">                    getEntry(threadId).getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    getEntry(threadId).getLatch().acquire();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            unsubscribe(future, threadId);</span><br><span class="line">        &#125;</span><br><span class="line">//        get(lockAsync(leaseTime, unit));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>重点看下tryAcquire方法，把线程id作为一个参数传递进来，在这个方法里面，找到tryLockInnerAsync方法点进去，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; RFuture&lt;T&gt; tryLockInnerAsync(long leaseTime, TimeUnit unit, long threadId, RedisStrictCommand&lt;T&gt; command) &#123;</span><br><span class="line">      internalLockLeaseTime = unit.toMillis(leaseTime);</span><br><span class="line"></span><br><span class="line">      return commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, command,</span><br><span class="line">                &quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then &quot; +</span><br><span class="line">                    &quot;redis.call(&#x27;hset&#x27;, KEYS[1], ARGV[2], 1); &quot; +</span><br><span class="line">                    &quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot; +</span><br><span class="line">                    &quot;return nil; &quot; +</span><br><span class="line">                &quot;end; &quot; +</span><br><span class="line">                &quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot; +</span><br><span class="line">                    &quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot; +</span><br><span class="line">                    &quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot; +</span><br><span class="line">                    &quot;return nil; &quot; +</span><br><span class="line">                &quot;end; &quot; +</span><br><span class="line">                &quot;return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;,</span><br><span class="line">                  Collections.&lt;Object&gt;singletonList(getName()), internalLockLeaseTime, getLockName(threadId));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这里就是一堆Lua脚本，先看第一个if命令，先去判断 KEYS[1]（就是对应的锁key的名字），如果不存在，在hashmap里，设置一个属性为线程id，值为1，再把map的过期时间设置为internalLockLeaseTime，这个值默认是30秒，<br><img src="https://upload-images.jianshu.io/upload_images/4366140-897216492ca05e4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>上面的操作对应的命令是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hset keyname id:thread 1</span><br><span class="line">pexpire keyname 30</span><br></pre></td></tr></table></figure>
<p>然后返回nil，相当于null，那程序return了。<br>另外，Redisson还支持重入锁，那第二个if就是执行重入锁的操作，会判断锁是否存在，并且传入的线程id是否是当前线程的id，若果是，支持重复加锁进行自增操作；<br>如果是其他线程调用lock方法，上面两个if判断不会走，会返回锁剩余过期时间。</p>
<p>接着返回到tryAcquireAsync方法里面往下看：<br>实际上是加了一个监听器，在监听器里面有个很重要的方法scheduleExpirationRenewal，一看这个名字就能大概猜出是什么功能，<br>里面有个定时任务的轮询，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">private void scheduleExpirationRenewal(final long threadId) &#123;</span><br><span class="line">       if (expirationRenewalMap.containsKey(getEntryName())) &#123;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Timeout task = commandExecutor.getConnectionManager().newTimeout(new TimerTask() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void run(Timeout timeout) throws Exception &#123;</span><br><span class="line">               // 判断传递进来的线程id是否是我们之前主线程设置的id，如果是，则增加续命，增加30秒。</span><br><span class="line">               RFuture&lt;Boolean&gt; future = commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,</span><br><span class="line">                       &quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot; +</span><br><span class="line">                           &quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot; +</span><br><span class="line">                           &quot;return 1; &quot; +</span><br><span class="line">                       &quot;end; &quot; +</span><br><span class="line">                       &quot;return 0;&quot;,</span><br><span class="line">                         Collections.&lt;Object&gt;singletonList(getName()), internalLockLeaseTime, getLockName(threadId));</span><br><span class="line">               </span><br><span class="line">               future.addListener(new FutureListener&lt;Boolean&gt;() &#123;</span><br><span class="line">                   @Override</span><br><span class="line">                   public void operationComplete(Future&lt;Boolean&gt; future) throws Exception &#123;</span><br><span class="line">                       expirationRenewalMap.remove(getEntryName());</span><br><span class="line">                       if (!future.isSuccess()) &#123;</span><br><span class="line">                           log.error(&quot;Can&#x27;t update lock &quot; + getName() + &quot; expiration&quot;, future.cause());</span><br><span class="line">                           return;</span><br><span class="line">                       &#125;</span><br><span class="line">                       </span><br><span class="line">                       if (future.getNow()) &#123;</span><br><span class="line">                           // reschedule itself</span><br><span class="line">                           scheduleExpirationRenewal(threadId);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;, internalLockLeaseTime / 3, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">       if (expirationRenewalMap.putIfAbsent(getEntryName(), task) != null) &#123;</span><br><span class="line">           task.cancel();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>接着推迟10秒钟（internalLockLeaseTime / 3），再执行续命操作逻辑。</p>
<p>到最后，再回到lockInterruptibly方法，<br>如果ttl 为null，说明加锁成功了，就返回null，那如果其他线程的话，就会返回剩余过期时间，那么就会进入到while死循环里，一直尝试加锁，调用tryAcquire方法，在琐失效以后，再会尝试获取加锁。</p>
<p>到此为止，分析完毕。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2017/01/12/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" data-id="ckvt3mzqj0000a4u076ovgan3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li></ul>

    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Java/" style="font-size: 10px;">Java</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">十一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/11/10/Java-8-Date-Time-API-%E8%AF%A6%E8%A7%A3/">Java 8 Date-Time API 详解</a>
          </li>
        
          <li>
            <a href="/2017/01/12/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">Redis分布式锁的使用与实现原理</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 Yannnn<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>