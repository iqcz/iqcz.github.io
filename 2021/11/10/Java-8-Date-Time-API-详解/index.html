<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.8.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta name="description" content="从Java版本1.0开始就支持日期和时间，主要通过java.util.Date类。 但是，Date类设计不佳。 例如，Date中的月份从1开始，但从日期却从0开始。在JDK 1.1中使用它的许多方法已经废弃，同时java.util.Calendar被引入来接管Date中的一些功能。 这两个是处理日期和时间的主要类，直到JDK 1.7，尽管他们被认为是不足够并且不容易处理，导致许多人诉诸第三方替代品">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 8 Date-Time API 详解">
<meta property="og:url" content="http://example.com/2021/11/10/Java-8-Date-Time-API-%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="当代十八线，浪漫主义码农诗人。">
<meta property="og:description" content="从Java版本1.0开始就支持日期和时间，主要通过java.util.Date类。 但是，Date类设计不佳。 例如，Date中的月份从1开始，但从日期却从0开始。在JDK 1.1中使用它的许多方法已经废弃，同时java.util.Calendar被引入来接管Date中的一些功能。 这两个是处理日期和时间的主要类，直到JDK 1.7，尽管他们被认为是不足够并且不容易处理，导致许多人诉诸第三方替代品">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-11-10T06:41:15.000Z">
<meta property="article:modified_time" content="2021-11-10T06:42:10.341Z">
<meta property="article:author" content="Yannnn">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2021/11/10/Java-8-Date-Time-API-%E8%AF%A6%E8%A7%A3/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2021/11/10/Java-8-Date-Time-API-%E8%AF%A6%E8%A7%A3/","path":"2021/11/10/Java-8-Date-Time-API-详解/","title":"Java 8 Date-Time API 详解"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Java 8 Date-Time API 详解 | 当代十八线，浪漫主义码农诗人。</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">当代十八线，浪漫主义码农诗人。</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Hyper Focus</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Overview"><span class="nav-number">1.</span> <span class="nav-text">Overview</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Instant%E7%B1%BB"><span class="nav-number">2.</span> <span class="nav-text">Instant类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#LocalDate%E7%B1%BB"><span class="nav-number">3.</span> <span class="nav-text">LocalDate类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Period%E7%B1%BB"><span class="nav-number">4.</span> <span class="nav-text">Period类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#LocalDateTime%E7%B1%BB"><span class="nav-number">5.</span> <span class="nav-text">LocalDateTime类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Time-Zones"><span class="nav-number">6.</span> <span class="nav-text">Time Zones</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ZonedDateTime"><span class="nav-number">7.</span> <span class="nav-text">ZonedDateTime</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Duration"><span class="nav-number">8.</span> <span class="nav-text">Duration</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Formatting-A-Date-Time"><span class="nav-number">9.</span> <span class="nav-text">Formatting A Date-Time</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Parsing-A-Date-Time"><span class="nav-number">10.</span> <span class="nav-text">Parsing A Date-Time</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Summary"><span class="nav-number">11.</span> <span class="nav-text">Summary</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Yannnn</p>
  <div class="site-description" itemprop="description">Java | Reading | Algorithm</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">2</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/10/Java-8-Date-Time-API-%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yannnn">
      <meta itemprop="description" content="Java | Reading | Algorithm">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="当代十八线，浪漫主义码农诗人。">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java 8 Date-Time API 详解
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-11-10 14:41:15 / 修改时间：14:42:10" itemprop="dateCreated datePublished" datetime="2021-11-10T14:41:15+08:00">2021-11-10</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>从Java版本1.0开始就支持日期和时间，主要通过<code>java.util.Date</code>类。 但是，<code>Date</code>类设计不佳。 例如，<code>Date</code>中的月份从1开始，但从日期却从0开始。在JDK 1.1中使用它的许多方法已经废弃，同时<code>java.util.Calendar</code>被引入来接管<code>Date</code>中的一些功能。 这两个是处理日期和时间的主要类，直到JDK 1.7，尽管他们被认为是不足够并且不容易处理，导致许多人诉诸第三方替代品，例如Joda Time（http://<a target="_blank" rel="noopener" href="http://joda.org/">joda.org</a>）。 JDK 1.8中的新日期和时间API解决了旧API中的许多问题，并且与Joda Time API类似。</p>
<p>这里介绍JDK 1.8中的日期 - 时间的API。</p>
<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>新的日期和时间API使得使用日期和时间非常容易。<code>java.time</code>包中包含API中的核心类。 另外，还有其他四个包，其成员使用较少：<code>java.time.chrono</code>，<code>java.time.format</code>，<code>java.time.temporal</code>和<code>java.time.zone</code>。</p>
<p>在<code>java.time</code>包中，<code>Instant</code>类表示时间线上的一个点，通常用于对时间进行操作。 <code>LocalDate</code>类为没有时间和时区部分的日期建模，例如，用于表示生日。</p>
<p>如果你需要日期和时间，那么<code>LocalDateTime</code>就是为你准备的。 例如，订单发货日期可能需要一个日期以外的时间来使订单更容易跟踪。 如果你需要一段时间但不关心日期，那么可以使用<code>LocalTime</code>。</p>
<p>如果时区很重要，日期和时间API提供<code>ZonedDateTime</code>类。 顾名思义，这个类表示带有时区日期时间。 例如，你可以使用此类来计算位于不同时区的两个机场之间的飞行时间。</p>
<p>然后有两个类来测量时间总计，即<code>Duration</code>类和<code>Period</code>类。 <strong>这两个类是相似的，除了<code>Duration</code>是基于时间，但而<code>Period</code>是基于日期的</strong>。 <code>Duration</code>提供了纳秒精度的时间量。 例如，可以模拟飞行时间，因为它通常以小时数和分钟数表示。 另一方面，如果只关心天数，月数或年数，例如计算一个人的年龄，则<code>Period</code>更为适用。</p>
<p><code>java.time</code>包也带有两个枚举<code>DayOfWeek</code>和<code>Month</code>。 <code>DayOfWeek</code>表示从一周的一天，从周一开始到周日。 <code>Month</code>枚举代表这一年的十二个月，从1月到12月。</p>
<p>处理日期和时间通常涉及解析和格式。 日期和时间API通过在所有主要类中提供<code>parse</code>和<code>format</code>方法来解决这两个问题。 另外，<code>java.time.format</code>包含一个用于格式化日期和时间的<code>DateTimeFormatter</code>类。</p>
<hr>
<h1 id="Instant类"><a href="#Instant类" class="headerlink" title="Instant类"></a>Instant类</h1><p><code>Instant</code>实例表示时间线上的一个点。 参考点是标准的Java纪元(epoch)，即1970-01-01T00：00：00Z（1970年1月1日00:00 GMT）。 <code>Instant类的</code>EPOCH<code>属性返回表示Java纪元的</code>Instant`实例。 在纪元之后的时间是正值，而在此之前的时间即是负值。</p>
<p><code>Instant</code>的静态<code>now</code>方法返回一个表示当前时间的<code>Instant</code>对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Instant now = Instant.now();</span><br></pre></td></tr></table></figure>

<p><code>getEpochSecond</code>方法返回自纪元以来经过的秒数。 <code>getNano</code>方法返回自上一秒开始以来的纳秒数。</p>
<p><code>Instant</code>类的一个常用用途是用来操作时间，如以下代码所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import java.time.Duration;</span><br><span class="line"></span><br><span class="line">import java.time.Instant;</span><br><span class="line"></span><br><span class="line">public class InstantDemo1 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Instant start = Instant.now();</span><br><span class="line"></span><br><span class="line">        // do something here</span><br><span class="line"></span><br><span class="line">        Instant end = Instant.now();</span><br><span class="line"></span><br><span class="line">        System.out.println(Duration.between(start, end).toMillis());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上面代码所示，<code>Duration</code>类用于返回两个<code>Instant</code>之间时间数量的差异。</p>
<hr>
<h1 id="LocalDate类"><a href="#LocalDate类" class="headerlink" title="LocalDate类"></a>LocalDate类</h1><p><code>LocalDate</code>类只包括日期没有时间的部分。 它也没有时区。 下表显示了<code>LocalDate</code>中一些重要的方法。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>now</td>
<td>静态方法，返回今天的日期</td>
</tr>
<tr>
<td>of</td>
<td>从指定年份，月份和日期创建LocalDate的静态方法</td>
</tr>
<tr>
<td>getDayOfMonth, getMonthValue, getYear</td>
<td>以int形式返回此LocalDate的日，月或年</td>
</tr>
<tr>
<td>getMonth</td>
<td>以Month枚举常量返回此LocalDate的月份</td>
</tr>
<tr>
<td>plusDays, minusDays</td>
<td>给LocalDate添加或减去指定的天数</td>
</tr>
<tr>
<td>plusWeeks, minusWeeks</td>
<td>给LocalDate添加或减去指定的星期数</td>
</tr>
<tr>
<td>plusMonths, minusMonths</td>
<td>给LocalDate添加或减去指定的月份数</td>
</tr>
<tr>
<td>plusYears, minusYears</td>
<td>给LocalDate添加或减去指定的年数</td>
</tr>
<tr>
<td>isLeapYear</td>
<td>检查LocalDate指定的年份是否为闰年</td>
</tr>
<tr>
<td>isAfter, isBefore</td>
<td>检查此LocalDate是在给定日期之后还是之前</td>
</tr>
<tr>
<td>lengthOfMonth</td>
<td>返回此LocalDate中月份的天数</td>
</tr>
<tr>
<td>withDayOfMonth</td>
<td>返回此LocalDate的拷贝，将月份中的某天设置为给定值</td>
</tr>
<tr>
<td>withMonth</td>
<td>返回此LocalDate的拷贝，其月份设置为给定值</td>
</tr>
<tr>
<td>withYear</td>
<td>返回此LocalDate的拷贝，并将年份设置为给定值</td>
</tr>
</tbody></table>
<p><code>LocalDate</code>提供了各种创建日期的方法。 例如，要创建代表今天日期的<code>LocalDate</code>，使用静态<code>now</code>方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalDate today = LocalDate.now();</span><br></pre></td></tr></table></figure>

<p>要创建代表特定年，月和日的<code>LocalDate</code>，使用<code>of</code>方法，该方法也是静态的。 例如，以下代码创建了一个代表2018年3月7日的<code>LocalDate</code>实例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalDate date = LocalDate.of(2018, 3, 7);</span><br></pre></td></tr></table></figure>
<p>还有一个接受<code>java.time.Month</code>枚举的常量作为第二个参数的<code>of</code>方法。 例如，下面是使用第二种方法重载构造相同日期的代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalDate date = LocalDate.of(2018, Month.MARCH, 7);</span><br></pre></td></tr></table></figure>
<p>还有获取<code>LocalDate</code>的日，月或年的方法，例如<code>getDayOfMonth</code>，<code>getMonth</code>，<code>getMonthValue</code>和<code>getYear</code>。 他们都没有任何参数，并返回一个int或<code>Month</code>的枚举常量。 另外，还有一个<code>get</code>方法，它接受一个<code>TemporalField</code>并返回这个<code>LocalDate</code>的一部分。 例如，传递<code>ChronoField.YEAR以</code>获取<code>LocalDate</code>的年份部分。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int year = localDate.get(ChronoField.YEAR);</span><br></pre></td></tr></table></figure>

<p><code>ChronoField</code>是一个实现<code>TemporalField</code>接口的枚举，因此可以传递一个<code>ChronoField</code>常量来获取。 <code>TemporalField</code>和<code>ChronoField</code>都是<code>java.time.temporal</code>包的一部分。 但是，并非<code>ChronoField</code>中的所有常量都可以<code>get</code>获取，因为并非所有常量都受支持。 例如，传递<code>ChronoField.SECOND_OF_DAY</code>以引发异常。 因此，取而代之，最好使用<code>getMonth</code>，<code>getYear</code>或类似方法来获取<code>LocalDate</code>的组件。</p>
<p>此外，还有拷贝<code>LocalDate</code>的方法，例如<code>plusDays</code>，<code>plusYears</code>，<code>minusMonths</code>等等。 例如，要获取表示明天的<code>LocalDate</code>，可以创建一个代表今天的<code>LocalDat</code>e，然后调用其<code>plusDays</code>方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalDate tomorrow = LocalDate.now().plusDays(1);</span><br></pre></td></tr></table></figure>
<p>要获取昨天表示的<code>LocalDate</code>，可以使用<code>minusDays</code>方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalDate yesterday = LocalDate.now().minusDays(1);</span><br></pre></td></tr></table></figure>
<p>另外，还有<code>plus</code>和<code>minus</code>方法以更通用的方式获得<code>LocalDate</code>的拷贝。 两者都接受一个int参数和一个<code>TemporalUnit</code>参数。 这些方法的签名如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public LocalDate plus(long amountToAdd,</span><br><span class="line"></span><br><span class="line">        java.time.temporal.TemporalUnit unit)</span><br><span class="line"></span><br><span class="line">public LocalDate minus(long amountToSubtract,</span><br><span class="line"></span><br><span class="line">        java.time.temporal.TemporalUnit unit)</span><br></pre></td></tr></table></figure>
<p>例如，获得一个从今天开始前20年的<code>LocalDate</code>，可以使用这段代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalDate pastDate = LocalDate.now().minus(2, ChronoUnit.DECADES);</span><br></pre></td></tr></table></figure>

<p><code>ChronoUnit</code>是一个实现<code>TemporalUnit</code>的枚举，因此可以将<code>ChronoUnit</code>常量传递给<code>plus</code>和<code>minus</code>方法。</p>
<p><code>LocalDate</code>是不可变的，因此无法更改。 任何返回<code>LocalDate</code>的方法都返回<code>LocalDate</code>的新实例。</p>
<p>以下是使用<code>LocalDate</code>的例子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import java.time.LocalDate;</span><br><span class="line">import java.time.temporal.ChronoField;</span><br><span class="line">import java.time.temporal.ChronoUnit;</span><br><span class="line"></span><br><span class="line">public class LocalDateDemo1 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        LocalDate today = LocalDate.now();</span><br><span class="line">         LocalDate tomorrow = today.plusDays(1);</span><br><span class="line">         LocalDate oneDecadeAgo = today.minus(1, ChronoUnit.DECADES);</span><br><span class="line"></span><br><span class="line">         System.out.println(&quot;Day of month: &quot; + today.getDayOfMonth());</span><br><span class="line">         System.out.println(&quot;Today is &quot; + today);</span><br><span class="line">         System.out.println(&quot;Tomorrow is &quot; + tomorrow);</span><br><span class="line">         System.out.println(&quot;A decade ago was &quot; + oneDecadeAgo);</span><br><span class="line">         System.out.println(&quot;Year : &quot; + today.get(ChronoField.YEAR));</span><br><span class="line">         System.out.println(&quot;Day of year:&quot; + today.getDayOfYear());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Period类"><a href="#Period类" class="headerlink" title="Period类"></a>Period类</h1><p><code>Period</code>类基于日期的时间数量构建，例如五天，一周或三年。 下面列出了一些重要的方法。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>between</td>
<td>在两个LocalDates之间创建一个Period示例</td>
</tr>
<tr>
<td>ofDays, ofWeeks, ofMonths, ofYears</td>
<td>创建代表给定天数/周/月/年的Period实例</td>
</tr>
<tr>
<td>of</td>
<td>根据给定的年数，月数和天数创建一个Period实例</td>
</tr>
<tr>
<td>getDays, getMonths, getYears</td>
<td>以int形式返回此Period的天数/月/年</td>
</tr>
<tr>
<td>isNegative</td>
<td>如果此Period的三个部分中的任何一个为负数，则返回true。 否则返回false</td>
</tr>
<tr>
<td>isZero</td>
<td>如果此Period的所有三个部分均为零，则返回true。 否则，返回false</td>
</tr>
<tr>
<td>plusDays, minusDays</td>
<td>在此Period上添加或减去给定的天数</td>
</tr>
<tr>
<td>plusMonths, minusMonths</td>
<td>在此Period上增加或减去给定的月数</td>
</tr>
<tr>
<td>plusYears, minusYears</td>
<td>在此Period增加或减去给定的年数</td>
</tr>
<tr>
<td>withDays</td>
<td>以指定的天数返回此Period的拷贝</td>
</tr>
<tr>
<td>withMonths</td>
<td>以指定的月数返回此Period的拷贝</td>
</tr>
<tr>
<td>withYears</td>
<td>以指定的年数返回此Period的拷贝</td>
</tr>
</tbody></table>
<p>创建一个<code>Period</code>很简单，这要感谢<code>between</code>,<code> of</code>,<code>ofDays</code> / <code>ofWeeks</code> / <code>ofMonths</code> / <code>ofYears</code>等静态工厂方法。 例如，以下是如何创建代表两周的<code>Period</code>实例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Period twoWeeks = Period.ofWeeks(2);</span><br></pre></td></tr></table></figure>

<p>要创建代表一年两个月三天的<code>Period</code>实例，请使用<code>of</code>方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Period p = Period.of(1, 2, 3);</span><br></pre></td></tr></table></figure>
<p>要获取某个期间的年/月/日组件，调用其<code>getYears</code> / <code>getMonths</code> / <code>getDays</code>方法。 例如，以下代码中的<code>howManyDays</code>变量的值是14。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Period twoWeeks = Period.ofWeeks(2);</span><br><span class="line"></span><br><span class="line">int howManyDays = twoWeeks.getDays();</span><br></pre></td></tr></table></figure>

<p>最后，可以使用<code>plusXXX</code>或<code>minusXXX</code>方法以及<code>withXXX</code>方法来创建<code>Period</code>的拷贝。 <code>Period</code>是不可变的，所以这些方法返回新的<code>Period</code>实例。</p>
<p>例如，下面的代码显示了一个计算个人年龄的年龄计算器。 它从两个<code>LocalDate</code>创建一个<code>Period</code>并调用它的<code>getDays</code>，<code>getMonths</code>和<code>getYears</code>方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import java.time.LocalDate;</span><br><span class="line">import java.time.Period;</span><br><span class="line"></span><br><span class="line">public class PeriodDemo1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        LocalDate dateA = LocalDate.of(1978, 8, 26);</span><br><span class="line">        LocalDate dateB = LocalDate.of(1988, 9, 28);</span><br><span class="line">        Period period = Period.between(dateA, dateB);</span><br><span class="line">        System.out.printf(&quot;Between %s and %s&quot;</span><br><span class="line">                + &quot; there are %d years, %d months&quot;</span><br><span class="line">                + &quot; and %d days%n&quot;, dateA, dateB,</span><br><span class="line">                period.getYears(),</span><br><span class="line">                period.getMonths(),</span><br><span class="line">                period.getDays());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行<code>PeriodDemo1</code>类打印下面字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Between 1978-08-26 and 1988-09-28 there are 10 years, 1 months and 2 days</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="LocalDateTime类"><a href="#LocalDateTime类" class="headerlink" title="LocalDateTime类"></a>LocalDateTime类</h1><p><code>LocalDateTime</code>类是一个没有时区的日期时间的构建。 下表显示了<code>LocalDateTime</code>中一些重要的方法。 这些方法类似于<code>LocalDate</code>的方法，以及用于修改时间部分的一些其他方法，例如在<code>LocalDate</code>中不可用的<code>plusHours</code>，<code>plusMinutes</code>和<code>plusSeconds</code>。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>now</td>
<td>返回当前日期和时间的静态方法。</td>
</tr>
<tr>
<td>of</td>
<td>从指定年份，月份，日期，小时，分钟，秒和毫秒创建LocalDateTime的静态方法。</td>
</tr>
<tr>
<td>getYear, getMonthValue, getDayOfMonth, getHour, getMinute, getSecond</td>
<td>以int形式返回此LocalDateTime的年，月，日，小时，分钟或秒部分。</td>
</tr>
<tr>
<td>plusDays, minusDays</td>
<td>给当前LocalDateTime添加或减去指定的天数。</td>
</tr>
<tr>
<td>plusWeeks, minusWeeks</td>
<td>给当前LocalDateTime添加或减去指定的周数。</td>
</tr>
<tr>
<td>plusMonths, minusMonths</td>
<td>给当前LocalDateTime添加或减去指定的月数。</td>
</tr>
<tr>
<td>plusYears, minusYears</td>
<td>给当前LocalDateTime添加或减去指定的年数。</td>
</tr>
<tr>
<td>plusHours, minusHours</td>
<td>给当前LocalDateTime添加或减去指定的小时数</td>
</tr>
<tr>
<td>plusMinutes, minusMinutes</td>
<td>给当前LocalDateTime添加或减去指定的分钟数</td>
</tr>
<tr>
<td>plusSeconds, minusSeconds</td>
<td>给当前LocalDateTime添加或减去指定的秒数</td>
</tr>
<tr>
<td>IsAfter, isBefore</td>
<td>检查此LocalDateTime是否在指定的日期时间之后或之前</td>
</tr>
<tr>
<td>withDayOfMonth</td>
<td>返回此LocalDateTime的拷贝，并将月份中的某天设置为指定值</td>
</tr>
<tr>
<td>withMonth, withYear</td>
<td>返回此LocalDateTime的拷贝，其月或年设置为指定值</td>
</tr>
<tr>
<td>withHour, withMinute, withSecond</td>
<td>返回此LocalDateTime的拷贝，其小时/分钟/秒设置为指定值</td>
</tr>
</tbody></table>
<p><code>LocalDateTime</code>提供了各种静态方法来创建日期时间。 该方法现在带有三个重载方法返回当前的日期时间。 无参的方法是最容易使用的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime now = LocalDateTime.now();</span><br></pre></td></tr></table></figure>

<p>要创建具有特定日期和时间的<code>LocalDateTime</code>，请使用<code>of</code>方法。 此方法有多个重载，并允许传递日期时间或<code>LocalDate</code>和<code>LocalTime</code>的单个部分。 以下是一些方法的签名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static LocalDateTime of(int year, int month, int dayOfMonth,</span><br><span class="line">        int hour, int minute)</span><br><span class="line"></span><br><span class="line">public static LocalDateTime of(int year, int month, int dayOfMonth,</span><br><span class="line">        int hour, int minute)</span><br><span class="line"></span><br><span class="line">public static LocalDateTime of(int year, Month month,</span><br><span class="line">        int dayOfMonth, int hour, int minute)</span><br><span class="line"></span><br><span class="line">public static LocalDateTime of(int year, Month month,</span><br><span class="line">        int dayOfMonth, int hour, int minute)</span><br><span class="line"></span><br><span class="line">public static LocalDateTime of(LocalDate date, LocalTime time)</span><br></pre></td></tr></table></figure>

<p>例如，下面的代码段创建一个<code>LocalDateTime</code>，代表2015年12月31日早上八点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime endOfYear = LocalDateTime.of(2015, 12, 31, 8, 0);</span><br></pre></td></tr></table></figure>

<p>可以使用<code>plusXXX</code>或<code>minusXXX</code>方法创建<code>LocalDateTime</code>的拷贝。 例如，此代码创建一个<code>LocalDateTime</code>，它表示明天的同一时间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime now = LocalDateTime.now();</span><br><span class="line"></span><br><span class="line">LocalDateTime sameTimeTomorrow = now.plusHours(24);</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Time-Zones"><a href="#Time-Zones" class="headerlink" title="Time Zones"></a>Time Zones</h1><p>互联网数字分配机构（IANA）维护一个可从此网页下载的时区数据库：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[http://www.iana.org/time-zones](http://www.iana.org/time-zones)</span><br></pre></td></tr></table></figure>
<p>但为了便于查看，可以访问此Wikipedia页面：<br><a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/List_of_tz_database_time_zones">http://en.wikipedia.org/wiki/List_of_tz_database_time_zones</a></p>
<p>Java日期和时间API也适用于时区。 抽象类<code>ZoneId</code>（在<code>java.time</code>包中）表示一个区域标识符。 它有一个名为<code>getAvailableZoneIds</code>的静态方法，它返回所有区域标识符。 下面展示了如何使用这种方法打印所有时区的排序列表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import java.time.ZoneId;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class TimeZoneDemo1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Set&lt;String&gt; allZoneIds = ZoneId.getAvailableZoneIds();</span><br><span class="line">        List&lt;String&gt; zoneList = new ArrayList&lt;&gt;(allZoneIds);</span><br><span class="line">        Collections.sort(zoneList);      </span><br><span class="line">        for (String zoneId : zoneList) &#123;</span><br><span class="line">            System.out.println(zoneId);</span><br><span class="line">        &#125;</span><br><span class="line">        // alternatively, you can use this line of code to</span><br><span class="line">        // print a sorted list of zone ids</span><br><span class="line">        // ZoneId.getAvailableZoneIds().stream().sorted().</span><br><span class="line">        //        forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>getAvailableZoneIds</code>返回字符串的<code>Set</code>集合。 可以使用<code>Collections.sort()</code>或更优雅地通过调用它的<code>stream</code>方法对<code>Set</code>进行排序。 可以编写此代码对区域标识符进行排序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZoneId.getAvailableZoneIds().stream().sorted()</span><br><span class="line">        .forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p><code>getAvailableZoneIds</code>返回586个区域标识符的<code>Set</code>集合。 以下是上述代码中的一部分区域标识符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Africa/Cairo</span><br><span class="line">Africa/Johannesburg</span><br><span class="line">America/Chicago</span><br><span class="line">America/Los_Angeles</span><br><span class="line">America/Mexico_City</span><br><span class="line">America/New_York</span><br><span class="line">America/Toronto</span><br><span class="line">Antarctica/South_Pole</span><br><span class="line">Asia/Hong_Kong</span><br><span class="line">Asia/Shanghai</span><br><span class="line">Asia/Tokyo</span><br><span class="line">Australia/Melbourne</span><br><span class="line">Australia/Sydney</span><br><span class="line">Canada/Atlantic</span><br><span class="line">Europe/Amsterdam</span><br><span class="line">Europe/London</span><br><span class="line">Europe/Paris</span><br><span class="line">US/Central</span><br><span class="line">US/Eastern</span><br><span class="line">US/Pacific</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="ZonedDateTime"><a href="#ZonedDateTime" class="headerlink" title="ZonedDateTime"></a>ZonedDateTime</h1><p><code>ZonedDateTime</code>类以一个时区为日期时间的构建。例如，以下是一个时区的日期时间:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2015-12-31T10:59:59+01:00 Europe/Paris</span><br></pre></td></tr></table></figure>
<p><code>ZonedDateTime</code>始终是不可变的，时间分量的存储精度为纳秒。</p>
<p><code>ZonedDateTIme</code>中一些重要方法的使用与<code>LocalDateTime</code>类似，只是多了一个时区的概念。可自行查阅API。</p>
<p>像<code>LocalDateTime</code>一样，<code>ZonedDateTime</code>类现在提供静态<code>now</code>和<code>of</code>方法，并构造一个<code>ZonedDateTime</code>实例。 <code>now</code>方法创建一个<code>ZonedDateTime</code>代表执行的日期和时间。 无参<code>now</code>方法会使用计算机的默认时区创建<code>ZonedDateTime</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZonedDateTime now = ZonedDateTime.now();</span><br></pre></td></tr></table></figure>
<p><code>now</code>的另一个重载方法允许传递区域标识符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZonedDateTime parisTime =</span><br><span class="line">        ZonedDateTime.now(ZoneId.of(&quot;Europe/Paris&quot;));</span><br></pre></td></tr></table></figure>

<p><code>of</code>方法也有好几个重载的方法。在所有情况下，都需要传递区域标识符。 第一个重载方法允许传递时区日期时间的每个部分，从年份到纳秒。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static ZonedDateTime of(int year, int month, int dayOfMonth,</span><br><span class="line">        int hour, int minute, int second, int nanosecond,</span><br><span class="line">        ZoneId zone)</span><br></pre></td></tr></table></figure>

<p><code>of</code>方法的第二个重载方法需要<code>LocalDate</code>，<code>LocalTime</code>和<code>ZoneId</code>参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public static ZonedDateTime of(LocalDate date, LocalTime time,</span><br><span class="line">        ZoneId zone)</span><br></pre></td></tr></table></figure>

<p><code>of</code>方法的最后一个重载方法需要<code>LocalDateTime</code>和<code>ZoneId</code>参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static ZonedDateTime of(LocalDateTime datetime, ZoneId zone)</span><br></pre></td></tr></table></figure>

<p>像<code>LocalDate</code>和<code>LocalDateTime</code>一样，<code>ZonedDateTime</code>提供了使用<code>plusXXX</code>，<code>minusXXX</code>和<code>withXXX</code>方法创建实例拷贝的方法。</p>
<p>例如，下面代码行创建一个带默认时区的<code>ZonedDateTime</code>，并调用它的<code>minusDays</code>方法以在三天前创建相同的<code>ZonedDateTime</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZonedDateTime now = ZonedDateTime.now();</span><br><span class="line">ZonedDateTime threeDaysEarlier = now.minusDays(3);</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Duration"><a href="#Duration" class="headerlink" title="Duration"></a>Duration</h1><p><code>Duration</code>类是基于时间的持续时间的构建。 它与<code>Period</code>类似，不同之处在于<code>Duration</code>的时间分量为纳秒精度，并考虑了<code>ZonedDateTime</code>实例之间的时区。 下表显示了<code>Duration</code>中重要的方法。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>between</td>
<td>在两个时差的对象之间创建一个Duration实例，例如在两个LocalDateTime或两个ZonedDateTime之间。</td>
</tr>
<tr>
<td>ofYears, ofMonths, ofWeeks, ofDays, ofHours, ofMinutes, ofSeconds, ofNano</td>
<td>创建给定年数/月/周/天/小时/分钟/秒/纳秒的Duration实例</td>
</tr>
<tr>
<td>of</td>
<td>根据指定数量的时间单位创建Duration实例</td>
</tr>
<tr>
<td>toDays, toHours, toMinutes</td>
<td>以int形式返回此Duration的天数/小时/分钟数</td>
</tr>
<tr>
<td>isNegative</td>
<td>如果此Duration为负，则返回true。 否则返回false。</td>
</tr>
<tr>
<td>isZero</td>
<td>如果此Duration长度为零，则返回true。 否则，返回false</td>
</tr>
<tr>
<td>plusDays, minusDays</td>
<td>在此Duration内添加或减去指定的天数。</td>
</tr>
<tr>
<td>plusMonths, minusMonths</td>
<td>在此Duration内添加或减去指定的月数。</td>
</tr>
<tr>
<td>plusYears, minusYears</td>
<td>在Duration内添加或减去指定的年数</td>
</tr>
<tr>
<td>withSeconds</td>
<td>以指定的秒数返回此Duration的拷贝。</td>
</tr>
</tbody></table>
<p>可以通过调用静态方法<code>between</code>或<code>of</code>来创建<code>Duration</code>。 下面的代码会在2015年1月26日11:10至2015年1月26日12:40之间创建两个<code>LocalDateTime</code>的<code>Duration</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import java.time.Duration;</span><br><span class="line">import java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line">public class DurationDemo1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        LocalDateTime dateTimeA = LocalDateTime</span><br><span class="line">                .of(2015, 1, 26, 8, 10, 0, 0);</span><br><span class="line">        LocalDateTime dateTimeB = LocalDateTime</span><br><span class="line">                .of(2015, 1, 26, 11, 40, 0, 0);</span><br><span class="line">        Duration duration = Duration.between(</span><br><span class="line">                dateTimeA, dateTimeB);</span><br><span class="line"></span><br><span class="line">        System.out.printf(&quot;There are %d hours and %d minutes.%n&quot;,</span><br><span class="line">                duration.toHours(),</span><br><span class="line">                duration.toMinutes() % 60);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行<code>DurationDemo1</code>类的结果是这样的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">There are 3 hours and 30 minutes.</span><br></pre></td></tr></table></figure>
<p>下面的代码在两个<code>ZoneDateTime</code>之间创建一个<code>Duration</code>，具有相同的日期和时间，但时区不同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import java.time.Duration;</span><br><span class="line">import java.time.LocalDateTime;</span><br><span class="line">import java.time.Month;</span><br><span class="line">import java.time.ZoneId;</span><br><span class="line">import java.time.ZonedDateTime;</span><br><span class="line"></span><br><span class="line">public class DurationDemo2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ZonedDateTime zdt1 = ZonedDateTime.of(</span><br><span class="line">                LocalDateTime.of(2015, Month.JANUARY, 1,</span><br><span class="line">                        8, 0),</span><br><span class="line">                ZoneId.of(&quot;America/Denver&quot;));</span><br><span class="line">        ZonedDateTime zdt2 = ZonedDateTime.of(</span><br><span class="line">                LocalDateTime.of(2015, Month.JANUARY, 1,</span><br><span class="line">                        8, 0),</span><br><span class="line">                ZoneId.of(&quot;America/Toronto&quot;));</span><br><span class="line"></span><br><span class="line">        Duration duration = Duration.between(zdt1, zdt2);</span><br><span class="line">        System.out.printf(&quot;There are %d hours and %d minutes.%n&quot;,</span><br><span class="line">                duration.toHours(),</span><br><span class="line">                duration.toMinutes() % 60);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行<code>DurationDemo2</code>类在控制台上打印如下结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">There are -2 hours and 0 minutes.</span><br></pre></td></tr></table></figure>
<p>这是预料之中的，因为时区<code>America/Denver</code>和<code>America/Toronto</code>之间有两个小时的差异。</p>
<p>作为一个更复杂的例子，下面的代码显示了一个公交车旅行时间计算器。 它有一个方法<code>calculateTravelTime</code>，它需要一个离开的<code>ZonedDateTime</code>实例和一个到达的<code>ZonedDateTime</code>实例。 该代码调用<code>calculateTravelTime</code>方法两次。 这两次公交车都在丹佛早上8点从科罗拉多州丹佛出发，并于多伦多时间第二天早上8点抵达多伦多。 公交车首次于2014年3月8日启程，第二次于2014年3月18日启程。</p>
<p>两种情况下的旅行时间是多少?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import java.time.Duration;</span><br><span class="line">import java.time.LocalDateTime;</span><br><span class="line">import java.time.Month;</span><br><span class="line">import java.time.ZoneId;</span><br><span class="line">import java.time.ZonedDateTime;</span><br><span class="line"></span><br><span class="line">public class TravelTimeCalculator &#123;</span><br><span class="line">    public Duration calculateTravelTime(</span><br><span class="line">            ZonedDateTime departure, ZonedDateTime arrival) &#123;</span><br><span class="line">        return Duration.between(departure, arrival);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        TravelTimeCalculator calculator =</span><br><span class="line">                new TravelTimeCalculator();</span><br><span class="line">        ZonedDateTime departure1 = ZonedDateTime.of(</span><br><span class="line">                LocalDateTime.of(2014, Month.MARCH, 8,</span><br><span class="line">                        8, 0),</span><br><span class="line">                ZoneId.of(&quot;America/Denver&quot;));</span><br><span class="line">        ZonedDateTime arrival1 = ZonedDateTime.of(</span><br><span class="line">                LocalDateTime.of(2014, Month.MARCH, 9,</span><br><span class="line">                        8, 0),</span><br><span class="line">                ZoneId.of(&quot;America/Toronto&quot;));</span><br><span class="line">        Duration travelTime1 = calculator</span><br><span class="line">                .calculateTravelTime(departure1, arrival1);</span><br><span class="line">        System.out.println(&quot;Travel time 1: &quot;</span><br><span class="line">                + travelTime1.toHours() + &quot; hours&quot;);</span><br><span class="line"></span><br><span class="line">        ZonedDateTime departure2 = ZonedDateTime.of(</span><br><span class="line">                LocalDateTime.of(2014, Month.MARCH, 18,</span><br><span class="line">                        8, 0),</span><br><span class="line">                ZoneId.of(&quot;America/Denver&quot;));</span><br><span class="line">        ZonedDateTime arrival2 = ZonedDateTime.of(</span><br><span class="line">                LocalDateTime.of(2014, Month.MARCH, 19,</span><br><span class="line">                        8, 0),</span><br><span class="line">                ZoneId.of(&quot;America/Toronto&quot;));</span><br><span class="line">        Duration travelTime2 = calculator</span><br><span class="line">                .calculateTravelTime(departure2, arrival2);</span><br><span class="line">        System.out.println(&quot;Travel time 2: &quot;</span><br><span class="line">                + travelTime2.toHours() + &quot; hours&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Travel time 1: 21 hours</span><br><span class="line"></span><br><span class="line">Travel time 2: 22 hours</span><br></pre></td></tr></table></figure>
<p>为什么有这个区别？ 因为2014年的夏令时从3月9日星期日凌晨2点开始。 因此，在2014年3月8日至2014年3月9日之间“失去”了一小时。</p>
<hr>
<h1 id="Formatting-A-Date-Time"><a href="#Formatting-A-Date-Time" class="headerlink" title="Formatting A Date-Time"></a>Formatting A Date-Time</h1><p>可以使用<code>java.time.format.DateTimeFormatter</code>格式化本地或时区日期时间。<code>LocalDate</code>，<code>LocalDateTime</code>，<code>LocalTime</code>和<code>ZoneDateTime</code>类提供具有以下签名的格式方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public java.lang.String format(java.time.format.DateTimeFormatter</span><br><span class="line">        formatter)</span><br></pre></td></tr></table></figure>

<p>很明显，要格式化日期或时间，必须首先创建<code>DateTimeFormatter</code>实例。</p>
<p>下面的代码使用两个格式化实例格式化当前日期。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import java.time.LocalDateTime;</span><br><span class="line">import java.time.format.DateTimeFormatter;</span><br><span class="line">import java.time.format.FormatStyle;</span><br><span class="line"></span><br><span class="line">public class DateTimeFormatterDemo1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        DateTimeFormatter formatter1 = DateTimeFormatter</span><br><span class="line">                .ofLocalizedDateTime(FormatStyle.MEDIUM);</span><br><span class="line">        LocalDateTime example = LocalDateTime.of(</span><br><span class="line">                2000, 3, 19, 10, 56, 59);</span><br><span class="line">        System.out.println(&quot;Format 1: &quot; + example</span><br><span class="line">                .format(formatter1));       </span><br><span class="line"></span><br><span class="line">        DateTimeFormatter formatter2 = DateTimeFormatter</span><br><span class="line">                .ofPattern(&quot;MMMM dd, yyyy HH:mm:ss&quot;);</span><br><span class="line">        System.out.println(&quot;Format 2: &quot; +</span><br><span class="line">                example.format(formatter2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：（第一个结果取决于你的区域设置）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Format 1: 19-Mar-2000 10:56:59 AM</span><br><span class="line"></span><br><span class="line">Format 2: March 19, 2000 10:56:59</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Parsing-A-Date-Time"><a href="#Parsing-A-Date-Time" class="headerlink" title="Parsing A Date-Time"></a>Parsing A Date-Time</h1><p>在Java Date和Time API的许多类中有两种<code>parse</code>方法。第一个需要格式化实例，第二个则不需要。后一个方法会根据默认模式解析日期时间。要使用自己的格式化模式，请使用<code>DateTimeFormatter</code>。如果传递的字符串不能被解析，那么解析方法将抛出一个<code>DateTimeParseException</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import java.time.LocalDate;</span><br><span class="line">import java.time.Period;</span><br><span class="line">import java.time.format.DateTimeFormatter;</span><br><span class="line">import java.time.format.DateTimeParseException;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">public class AgeCalculator &#123;</span><br><span class="line">    DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-M-d&quot;);</span><br><span class="line">    public Period calculateAge(LocalDate birthday) &#123;</span><br><span class="line">        LocalDate today = LocalDate.now();</span><br><span class="line">        return Period.between(birthday, today);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public LocalDate getBirthday() &#123;</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        LocalDate birthday;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            System.out.println(&quot;Please enter your birthday &quot;</span><br><span class="line">                    + &quot;in yyyy-MM-dd format (e.g. 1980-9-28): &quot;);</span><br><span class="line">            String input = scanner.nextLine();</span><br><span class="line">            try &#123;</span><br><span class="line">                birthday = LocalDate.parse(input, formatter);</span><br><span class="line">                return birthday;</span><br><span class="line">            &#125; catch(DateTimeParseException e) &#123;</span><br><span class="line">                System.out.println(&quot;Error! Please try again&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AgeCalculator ageCalculator = new AgeCalculator();</span><br><span class="line">        LocalDate birthday = ageCalculator.getBirthday();</span><br><span class="line">        Period age = ageCalculator.calculateAge(birthday);</span><br><span class="line">        System.out.printf(&quot;Today you are %d years, %d months&quot;</span><br><span class="line">                + &quot; and %d days old%n&quot;,</span><br><span class="line">                age.getYears(), age.getMonths(), age.getDays());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AgeCalculator</code>类有两个方法，<code>getBirthday</code>和<code>calculateAge</code>。 <code>getBirthday</code>方法使用<code>Scanner</code>类来读取用户输入，并使用<code>DateTimeFormatter</code>类将输入解析到<code>LocalDate</code>中。 <code>getBirthday</code>方法一直请求一个日期，直到用户输入正确格式的日期，在这种情况下，方法返回。 <code>calculateAge</code>方法需要一个生日，并在生日和今天的日期之间创建一个<code>Period</code>实例。</p>
<p>如果运行这个例子，会在控制台上看到这个。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Please enter your birthday in yyyy-MM-dd format (e.g. 1980-9-28):</span><br></pre></td></tr></table></figure>
<p>如果以正确的格式输入日期，则程序将打印计算的年龄，如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Today you are 79 years, 0 months and 15 days old</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><p>Java 8带来了全新的Date-Time API来替代以<code>java.util.Date</code>类为中心的旧的API。 通过本篇文章，学习如何使用新API中的核心类，如<code>Instant</code>，<code>LocalDate</code>，<code>LocalDateTime</code>，<code>ZonedDateTime</code>，<code>Period</code>和<code>Duration</code>，以及学习如何格式化和解析日期时间。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/11/10/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" rel="prev" title="Redis分布式锁的使用与实现原理">
                  <i class="fa fa-chevron-left"></i> Redis分布式锁的使用与实现原理
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yannnn</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
